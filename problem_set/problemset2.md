# Problem Set 2
## Concept Questions
1. The context is for how uniquess betweens nonces are generated. Nonces only have to unique inside one context, but between contexts, same nonce word can be used. Context is served as a limiting scope for the generation of nonces.
The context will be the shortbaseURL because the requirement in register in the URLShortening concept, says "no shortening exists for shortURLBase/shortUrlSuffix. Nonce can be intuitively associated with the suffix, and the uniquess defined in the requirement (the either or between base/suffix) matches with how nonce uniqueness is insured in NonceGeneration concept.

2. Set of used strings instead of a counter for each context is used because we want to allow the user to pick their own suffix for the shortenURL generated. Storing as set of used string is the most direct way. However, it's also really similar to counter by making sure an unique string/number to be used in the shortenSuffix. An abstraction function that allows both usage of counter and customized suffix is mapping the number to a suffix. The number only increment, giving unique keys mapping to unique strings.

3. One advantage of using common dictionary words besides easy memorization is user can define the suffix to be about the content of the url. This way, users who are clicking on it next time knows what the url is about and seeing an actual title gives trustworthiness of the website, making it less suspicious.
The disadvantage of it is single common words run out really fast. There's a limited number of words in the common word dictionary, meaning limiting users' ability of shortening as much url as they want. To modify NonceGeneration if we are using common dictionary words, we can suggest words from the common dictionary that had not been used for this context in case users can't think of any. If all single words are used, we can do pair combinations of common words, and combined with one or two digit numbers if more room is needed.

## Synchronization Questions
1. The first sync is for syncing generate, which is an action in NonceGeneration. Generate only requires context, which is the shortURLBase from UrlShortening. The targetUrl is irrelevant to the action in the 'then' clause, and thus omitted. The second sync has both because we are syncing register from UrlShortening this time, where register do requires shortURLBase and targetURL. UrlSuffix wasn't included because that is generated by the NonceGeneration.generate() instead.

2. This is not the convention every case because when trying to sync argument names between concepts' actions, they might not have the same name. For example, UrlSuffix would be equivalent to nonce in the NonceGeneration, but then the naming are not the same. It's necessary to be specific during times like this to clarify how arguments are synced with each other.

3. setExpiry happens not at the request of the user, but automatically after the user registered completely and had returned a shortenUrl. Different to the first two sync, where the action requires inputs from the users like targetUrl and shortBaseUrl and sometimes need to be pass down to different concepts.

4. NonceGeneration allows the same nonce to be exisiting in different context as long as there's only one copy in one context. However, if we only have one domain (one context), we won't need a shortBaseUrl from the user. For sync generate now, we don't need anything from the user, but we still need to sync we only generate after the user request the for the register action. For the other sync, if shortUrlBase is needed, just remove it because we know we only have one domain, bit.ly.

5.  **sync** delete
    **when** ExpiringResource.expireReSource():(resource)
    **then** URLShortening.delete(shortUrl: resource)

## Extending the design
1.
**concept** URLAccessTrack [ShortenURL]
**purpose** track the number of times a shortened URL has been lookup
**principle** Increment the count for the shortened URL on every visit by anyone (who has the link), only allow the user who registered the URL to be able to see the count

**state**
a set of ShortURLs with
    a count Number[^2]

**action**
increment(shortURL: shortURL)
    **effect** increase the count for shortURL by 1
getCount (shortURL:shortURL, user: User): (count:Number)
    **require** the shortURL was registered by user
    **effect** returns the visited count on shortURL
[^2] By default, all shortUrl count should be 0 when created, the user shouldn't be able to change the count themselves or create the concept 'count' to set the count to 0.
**concept** UserAccount
**purpose** keep track of what URLs belong to which user
**principle** each short URL is owned by a single user [^1]
**state**
a set of Users with
    userId String
    a set of shortURLs ShortUrl
**action**
    isOwner(userId:String,  shortURL: ShortURL): (result: Boolean)
        **require** userId corresponds to a real existing user
        **effect** returns true if shortURL is owned by user with userId, else vice versa
    setOwnership(userId: String, shortURL: ShortURL)
        **require** shortURL is not already owned and registered by user
        **effect** mark user as the owner of shortURL
[^1] For bit.ly service, users can't create same shortURL if already existing in the application system. It's not the focus for tracking URL ownership, but I just want to say I'm assuming distinct shortURL between all users to be like the bit.ly service.

<!--Specify three essential synchronizations with your new concepts: one that happens when shortenings are created; one when shortenings are translated to targets; and one when a user examines analytics. (Hint: for the last one, you can simplify by assuming a request for analytics that just asks for the number of lookups for a particular short URL, but that ensures that the result is not visible to everyone.)-->

2.
**sync** setOwnership
**when**
    UrlShortening.register():(shortUrl)
    Request.userId(String)
**then** UserAccount.setOwnership(userId: String, shortUrl)

**sync** increment
**when** UrlShortening.lookup(shortUrl)
**then** URLAccessTrack.increment(shortUrl)

**sync** getCount
**when** Request.URLAnalytics(userId,shortUrl)
**then** URLAccessTracking.getCount(shortUrl, userId)

3.
- Allowing users to choose their own short URLs;
    > This can be done already by the argument shortUrlSuffix in UrlShortening's register action. We can make the code to not run NonceGeneration.generate in sync if provided and we've checked the suffix follows the invariants of our application.
- Using the “word as nonce” strategy to generate more memorable short URLs
    > This can be done by changing how generate works internally inside NonceGeneration. Referring back to the common dictionary word idea can also make this feature request work as long as we are following the invariants. No need to change concepts or syncing.
- Including the target URL in analytics, so that lookups of different short URLs can be grouped together when they refer to the same target URL;
    > This feature request would require some change in the URLAccessTrack concept. We would have to keep track of targetUrl to all its shortUrl inside the user account. We need to put targetUrl inside the set of shortUrl. Then, we need to add an action of getCountForTargetUrl(targetUrl,user). Also need a new state where a set of targetUrl with count. We would also have to add a little more to the effect of increment, where we have to look up the targetUrl for the shortUrl then increment the count for the targetUrl as well. A new sync for the new action getCountForTargetUrl would be needed by falls in the same sync logic as the getCount sync right now.
- Generate short URLs that are not easily guessed;
    > This feature is great for keeping access more limited, but I think it's defeating the purpose of shortUrl, "shorter or more memorable way to link." Having a long url can satisfy this feature request, because even randomized shortUrl can be guessed by brute force. This feature is undesirable for the purpose of the shorteningUrl Application, not just one concept.
- Supporting reporting of analytics to creators of short URLs who have not registered as user.
    > This feature request would break privacy principles, in general to how people are concern about their online data status, by removing authentication. Even though this can be done by changing the UserAccount concept, purpose, principle, action, and sync, the complexity is too much from our current status of the application design. If a user is not registered, it's hard for companies to keep track of user identities and allows security risk.
